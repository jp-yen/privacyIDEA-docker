# -*- text -*-
##
## radiusd.conf -- FreeRADIUS サーバー設定ファイル - 3.2.7
##
##	http://www.freeradius.org/
##	$Id: 376892e151857fa35c22662769acef3dcea08ecc $
##

######################################################################
#
#	この（および他の）設定ファイルの書式は
#	"man unlang" に記載されています。多くのサブディレクトリにREADMEもあります:
#
#	  raddb/README.rst
#		v2からのアップグレード方法。
#
#	  raddb/mods-available/README.rst
#		mods-available / mods-enabled の使い方。
#		すべてのモジュールは個別ファイルにあり、
#		設定項目と完全なドキュメントが含まれています。
#
#	  raddb/sites-available/README
#		仮想サーバー、"listen" セクション、クライアントなど。
#		"sites-available" ディレクトリには
#		よくある設定例が多数あります。
#
#	  raddb/certs/README.md
#		EAPやRadSec用証明書の作成方法。
#
#	サーバーのすべての設定項目は
#	サンプル設定ファイルのコメントで詳細に説明されています。
#
#	この（または他の）設定ファイルを編集する前に、必ず
#	"man radiusd" を読んでください。DEBUGGING セクションを参照してください。
#	そこでは、最小限の労力で望む設定を素早く作成する方法が説明されています。
#
#	サーバーをデバッグモードで実行し、出力をよく読んでください。
#
#		$ radiusd -X
#
#	この点は非常に重要です。ほとんどの問題は
#	デバッグ出力を注意深く読むことで解決できます。
#	そこにはよくある問題の警告や、修正方法の提案が含まれています。
#
#	出力は多いかもしれませんが、"warning"、"error"、"reject"、"failure"
#	などの単語を注意深く探してください。そこに解決のヒントがあります。
#
#	"radiusd -X" の詳細なドキュメントは wiki にあります:
#		https://wiki.freeradius.org/radiusd-X
#
#	メーリングリストで質問する場合は、
#	やりたいことを説明し、デバッグモードの出力（radiusd -X）を添付してください。
#	これをしないと「radiusd -X の出力を貼ってください」と言われます。
#
#	メーリングリスト投稿のガイドラインは wiki にあります:
#		https://wiki.freeradius.org/list-help
#
#	投稿前に必ずガイドラインを読んでください。
#
#	さらなるドキュメントはサーバー配布物の "doc" ディレクトリや
#	wiki でも参照できます:
#		https://wiki.freeradius.org/
#
#	RADIUS初心者は Technical Guide を読むことを推奨します。
#	このガイドはRADIUSの仕組み、FreeRADIUSの仕組み、
#	RADIUSシステムの各部分の役割を説明しています。
#	単なる「FreeRADIUSの設定方法」ではありません！
#		https://networkradius.com/doc/FreeRADIUS-Technical-Guide.pdf
#
#	辞書、モジュール、unlang などの詳細なドキュメントも
#	Network RADIUS のWebサイトで参照できます:
#		https://networkradius.com/freeradius-documentation/
#

######################################################################

prefix = /usr
exec_prefix = /usr
sysconfdir = /etc
localstatedir = /var
sbindir = ${exec_prefix}/sbin
logdir = /var/log/freeradius
raddbdir = /etc/freeradius
radacctdir = ${logdir}/radacct

#
#  実行中のサーバーの名前。"-n" コマンドラインオプションも参照してください。
name = freeradius

#  設定ファイルとログファイルの場所。
confdir = ${raddbdir}
modconfdir = ${confdir}/mods-config
certdir = ${confdir}/certs
cadir   = ${confdir}/certs
run_dir = ${localstatedir}/run/${name}

# おそらく ${localstatedir}/lib/radiusd にするべきです
db_dir = ${raddbdir}

#
# libdir: rlm_* モジュールを探す場所。
#
#   これは通常、設定時に自動的に設定されます。
#
#   サーバーがビルド・インストールできても、実行時に
#   'undefined symbol' エラーで失敗する場合は、libdir
#   ディレクティブを使って問題を回避できます。
#
#   原因は、ライブラリがシステム上のダイナミックリンカが
#   見つけられない場所にインストールされていることが多いです。
#   root（または他のユーザー）で実行すると、個人の環境が
#   ダイナミックリンカにライブラリを見つけさせる場合があります。
#   デーモンとして実行すると、FreeRADIUSは同じ
#   個人設定を持たない場合があります。
#
#   問題を回避するには、そのシンボルを含むライブラリを見つけ、
#   そのライブラリがあるディレクトリを 'libdir' の末尾に追加します。
#   ディレクトリ名はコロンで区切ります。スペースは不可です。
#
#   例: libdir = /usr/local/lib:/opt/package/lib
#
#   サーバー起動スクリプトで LD_LIBRARY_PATH 環境変数を
#   設定することも試せます。
#
#   それでも動作しない場合は、共有ライブラリを使わないように
#   再設定・再ビルドしてください:
#
#	./configure --disable-shared
#	make
#	make install
#
libdir = /usr/lib/freeradius

#  pidfile: RADIUSサーバーのPIDを保存する場所。
#
#  サーバーが実行中にこのファイルを使ってシグナルを送ることができます。
#
#  このファイルはデーモンモードでのみ書き込まれます。
#
#  例:  kill -HUP `cat /var/run/radiusd/radiusd.pid`
#
pidfile = ${run_dir}/${name}.pid

#  panic_action: サーバーが予期せず終了した場合に実行するコマンド。
#
#  本番環境では、アクションは必ず終了するものにしてください。
#  対話的なアクションは、サーバーがリクエストに応答していないことを意味します。
#  対話的なアクションは、サーバーが再起動しないことを意味します。
#
#  サーバーは信頼できないパニックアクションコードを実行してはいけません。
#  PATTACHは攻撃ベクトルとして使われる可能性があります。
#
#  パニックアクションは、サーバーが致命的なユーザー生成以外のシグナル
#  （例: SIGSEGV, SIGBUS, SIGABRT, SIGFPE）を受け取った場合に実行されます。
#
#  これを使って対話的なデバッグセッションを開始し、
#  サーバーの現在の状態に関する情報を取得できます。
#
#  利用可能な文字列置換:
#  - %e   現在実行中のプログラム 例: /sbin/radiusd
#  - %p   現在実行中のプログラムのPID 例: 12345
#
#  標準の ${} 置換も利用可能です。
#
#  GDBで対話的セッションを開くパニックアクションの例:
#
#panic_action = "gdb %e %p"
#
#  ただし、これは本番環境では使わないでください。
#
#  GDBで自動セッションを開くパニックアクションの例:
#
#panic_action = "gdb -silent -x ${raddbdir}/panic.gdb %e %p 2>&1 | tee ${logdir}/gdb-${name}-%p.log"
#
#  このコマンドは本番環境でも利用できます。
#

#  max_request_time: リクエスト処理の最大時間（秒）。
#
#  この時間を超えて処理されるリクエストはkillされ、REJECTメッセージが返されます。
#
#  警告: リクエスト処理に長時間かかる場合は、サーバーや利用モジュール、
#  またはローカル設定にバグがある可能性があります。
#
#  この問題はSQLデータベース利用時によく見られます。SQLからの応答に
#  1～2秒以上かかる場合、インデックスが不足している可能性があります。
#  詳細はSQLサーバーのドキュメントを参照してください。
#
#  推奨値の範囲: 5～120
#
max_request_time = 30

#  cleanup_delay: NASに送信したリプライをクリーンアップするまでの待機時間（秒）。
#
#  RADIUSリクエストは通常、NASにリプライを送信した後、短期間内部でキャッシュされます。
#  リプライパケットがネットワークで失われると、NASはそれを受信できません。
#  その場合、NASはリクエストを再送し、サーバーはキャッシュされたリプライですぐに応答します。
#
#  この値が低すぎると、NASからの重複リクエストが検出できず、別リクエストとして処理される場合があります。
#
#  この値が高すぎると、サーバーが多くのリクエストをキャッシュしすぎて、新しいリクエストがブロックされる場合があります（'max_requests'参照）。
#
#  推奨値の範囲: 2～30
#
cleanup_delay = 5

#  max_requests: サーバーが追跡するリクエストの最大数。
#  この値はクライアント数×256にするべきです。
#  例: クライアントが4台なら1024。
#
#  この値が低すぎると、サーバーがビジーになったときに
#  'cleanup_delay'経過まで新規リクエストに応答できなくなります。
#
#  この値が高すぎると、サーバーは無駄に多くのメモリを使います。
#
#  迷った場合は高めに設定してください。クライアント1台あたり1000が上限目安です。
#
#  推奨値の範囲: 256～無限大
#
max_requests = 16384

#  hostname_lookups: クライアントの名前をログに記録するか、IPアドレスのみ記録するか
#  例: www.freeradius.org（on）または 206.47.27.232（off）
#
#  デフォルトは'off'です。なぜなら有効にすると各クライアントリクエストごとに
#  少なくとも1回名前解決が発生し、サーバーが30秒間ランダムに停止することもあるためです。
#
#  hostname_lookupsをoffにすると、名前のないIPアドレスでも30秒ブロックされません。
#
#  許可値: {no, yes}
#
hostname_lookups = no

#
#  "Post-Auth-Type Client-Lost" セクションを実行します。これはサーバーが
#  Access-Challenge を送信し、その後クライアントが応答しなかった場合のみ発生します。
#  管理者がクライアントが応答しなかったことを記録できるようにするのが目的です。
#
#  詳細は sites-available/default の "Post-Auth-Type Client-Lost" を参照してください。
#
#postauth_client_lost = no

#
#  Unlang の動作オプション
#
unlang {
	#
	#  デフォルトでは、"return" キーワードは現在の処理セクションを終了します。
	#  この2つのオプションにより、"return" を "group" セクションや "policy" セクション
	#  だけを抜けるために使うことができます。
	#
	#  これを yes に設定すると、group 内での "return" は group を抜けて
	#  その後の処理を継続します。
	#
#	group_stop_return = no

	#
	#  これを yes に設定すると、policy 内での "return" は policy を抜けて
	#  その後の処理を継続します。
	#
#	policy_stop_return = no
}

#
#  Logging section.  The various "log_*" configuration items
#  will eventually be moved here.
#
log {
	#
	#  ログメッセージの出力先。次のいずれかを指定できます:
	#
	#	files - 下記で定義された "file" へログ出力
	#	syslog - syslog へ出力（下記 "syslog_facility" も参照）
	#	stdout - 標準出力
	#	stderr - 標準エラー出力
	#
	#  コマンドラインオプション "-X" を指定するとこの設定を無視し、
	#  強制的にstdoutへ出力します。
	#
	destination = files

	#
	#  stderrやstdoutに送信される重要なメッセージを強調表示します。
	#
	#  TERMがxtermでない、またはTTYでない場合はこのオプションは無効（無視）されます。
	#
	colourise = yes

	#
	#  destination == "files" の場合、サーバーのログメッセージは
	#  このファイルの末尾に追記されます。
	#
	#  サーバーがデバッグモードで動作している場合、このファイルは
	#  使用されません。
	#
	file = ${logdir}/radius.log

	#
	#  ${destination} == "syslog" の場合、どのsyslogファシリティを使うか
	#
	#  ここで許可される値はOS依存です。通常は変更しないでください。
	#
	syslog_facility = daemon

	#  リクエストで見つかった User-Name 属性を完全にログに記録するかどうか。
	#
	# 許可値: {no, yes}
	#
	stripped_names = no

	#  認証結果（accept/reject両方）をすべてログファイルに記録するかどうか。
	#
	#  これは "auth_accept = yes" および "auth_reject = yes" を設定するのと同じです。
	#
	#  許可値: {no, yes}
	#
	auth = yes

	#  Access-Accept 結果をログファイルに記録するかどうか。
	#
	#  これは "auth = no" の場合のみ使用されます。
	#
	#  許可値: {no, yes}
	#
#	auth_accept = no

	#  Access-Reject 結果をログファイルに記録するかどうか。
	#
	#  これは "auth = no" の場合のみ使用されます。
	#
	#  許可値: {no, yes}
	#
#	auth_reject = no

	#  認証リクエスト時にパスワードをログに記録するかどうか。
	#  auth_badpass  - 拒否された場合にパスワードを記録
	#  auth_goodpass - 正しい場合にパスワードを記録
	#
	#  許可値: {no, yes}
	#
	auth_badpass = yes
	auth_goodpass = yes

	#  "Login OK" メッセージの末尾に追加テキストをログ出力する。
	#  これを有効にするには、上記 "auth" および "auth_goodpass" または "auth_badpass"
	#  の設定を "yes" にする必要があります。
	#
	#  下記の文字列は動的に展開されるため、任意の内容を指定できます。
	#  ただし、この展開は遅くなり、サーバー性能に悪影響を与える場合があります。
	#
#	msg_goodpass = ""
#	msg_badpass = ""

	#  ユーザーが Simultaneous-Use 制限を超えた場合のメッセージ。
	#
	msg_denied = "You are already logged in - access denied"

	#  デバッグモードでシークレット属性の表示を抑制する。
	#
	#  シークレットはxlat展開をまたいで追跡されません。
	#  設定でシークレットを他の文字列に含めた場合、それも表示されます。
	#
	#  これを "yes" に設定すると、サーバーは値の代わりに
	#
	#	<<< secret >>>
	#
	#  を表示します（User-Name, Tunnel-Password等のシークレット情報を含む属性）。
	#
	#  この設定はデフォルトで無効です。管理者が実際に送信されている内容を
	#  確認できることは非常に重要です。
	#
#	suppress_secrets = no
}

#  checkrad: 同時接続チェックを行うために実行されるプログラム。
checkrad = ${sbindir}/checkrad

#
#  環境変数
#
#  `$ENV{PATH}` のような展開で環境変数を参照できますが、
#  環境変数を設定したい場合もあります。このセクションで設定できます。
#
#  このセクションの主な目的は、RADIUS固有の設定を
#  RADIUSの設定ファイル内にまとめておくことです。
#  例えば、モジュールで使う環境変数を設定したい場合、
#  シェルスクリプトに書くよりもここに記載した方が便利です。
#
#  これらの環境変数は設定ファイルの読み込み後に設定されます。
#  そのため、ここでFOOを設定しても他の設定ファイルで
#  `$ENV{FOO}` として参照することはできません。
#  その場合は通常の設定変数を使ってください。
#
ENV {
	#
	#  環境変数 `FOO` に '/bar/baz' を設定します。
	#
	#  注意: 必ず '=' を使ってください。'+=' で値を追加することはできません。
	#
#	FOO = '/bar/baz'

	#
	#  環境変数 `BAR` を削除します。
	#
#	BAR

	#
	#  サーバーがKerberos認証情報を必要とする場合、以下のkeytabファイルに
	#  配置できます。
	#
	#  これにより、サーバーがデバッグモードで動作している場合でも
	#  その認証情報を利用できます。
	#
#	KRB5_CLIENT_KTNAME = ${raddbdir}/radiusd.keytab

	#
	#  `LD_PRELOAD` は特別です。通常はアプリケーション実行前に設定され、
	#  ダイナミックリンカによって解釈されます。
	#  つまり、アプリケーション内で設定してもライブラリはロードされません。
	#
	#  この機能は便利なので、ここで拡張しています。
	#
	#  以下のように設定できます:
	#
	#  LD_PRELOAD = /path/to/library.so
	#
	#  サーバーは指定されたライブラリをロードします。複数のライブラリは
	#  個別に `LD_PRELOAD` を複数指定することでロードできます。
	#
	#
#	LD_PRELOAD = /path/to/library1.so
#	LD_PRELOAD = /path/to/library2.so
}

# セキュリティ設定
#
#  サーバーへの攻撃方法はいくつか考えられます。
#  このセクションでは、それらの攻撃の影響を最小限に抑えるための
#  設定項目をまとめています。
#
security {
	#  chroot: サーバーが "chroot" するディレクトリ。
	#
	#  chrootはサーバー起動プロセスの非常に早い段階で実行されます。
	#  chroot後、下記で指定した "user" に切り替わります（必須）。
	#  "group" が指定されていれば、そのグループにも切り替わります。
	#  /etc/group で指定ユーザーに割り当てられている他のグループも
	#  すべて追加されます。
	#
	#  カレントディレクトリ（chdir / cd）は、すべてのモジュールが
	#  初期化されるまで *chroot外* に残されます。
	#  これにより "raddb" ディレクトリをchroot外に置くことができます。
	#  モジュール初期化後、${logdir} にchdirします。
	#  これによりchrootから抜け出すことは不可能になります。
	#
	#  このchdirの使い方にセキュリティ上の懸念がある場合は、
	#  "raddb" ディレクトリをchroot内に配置し、サーバー起動前に
	#  "cd raddb" を実行してください。
	#
	#  サーバーが静的リンクされている場合、chroot内に必要なのは
	#  ${run_dir} と ${logdir} だけです。上記のように "cd raddb" を
	#  行う場合は、"raddb" ディレクトリもchroot内に必要です。
	#
#	chroot = /path/to/chroot/directory

	# user/group: radiusdを実行するユーザー/グループ名（または番号）。
	#
	#   これらがコメントアウトされている場合、サーバーは
	#   起動したユーザー/グループで動作します。別のユーザー/グループに
	#   切り替えるには、root（またはroot権限）が必要です。
	#
	#   サーバーは可能な限り権限を減らして実行することを強く推奨します。
	#   つまり、シャドウパスワードを使わない場合は、下記のuser/groupを
	#   'radius'に設定してください。
	#
	#  注意: 一部のカーネルでは、(unsigned)group値が60000を超えると
	#  setgid(group)に失敗します。この場合 "nobody" グループは使わないでください。
	#
	#  シャドウパスワードを使うシステムでは、サーバーが
	#  シャドウファイルを読めるように 'group = shadow' を
	#  設定する必要があるかもしれません。デバッグモードでは認証できるが
	#  デーモンモードではできない場合、デバッグ時のユーザーは
	#  シャドウ情報を読めるが、下記のユーザーは読めない可能性があります。
	#
	#  サーバーは "initgroups" も使い、/etc/groups を読みます。
	#  "user" がメンバーのすべてのグループに参加します。
	#  これにより、より細かなアクセス制御が可能です。
	#
	#  コンテナ環境では、root で実行する場合があります
#	user = freerad
#	group = freerad

	#  コアダンプは望ましくありません。サーバーの問題をデバッグする場合のみ
	#  'yes' に設定してください。
	#
	#  許可値: {no, yes}
	#
	allow_core_dumps = no

	#
	#  max_attributes: RADIUSパケットで許可される属性の最大数。
	#  この数を超える属性を持つパケットは破棄されます。
	#
	#  この数が小さすぎると、RADIUSパケットが受け付けられなくなります。
	#
	#  この数が大きすぎると、攻撃者が少数のパケットで
	#  サーバーのメモリを使い切らせる可能性があります。
	#
	#  0に設定すると「属性数無制限」となります。
	max_attributes = 200

	#
	#  reject_delay: Access-Rejectを送信する際、数秒遅延させることができます。
	#  これによりDoS攻撃を遅らせたり、パスワード総当たり攻撃を
	#  遅らせる効果があります。
	#
	#  0に設定すると「即時reject送信」となります。
	#
	#  この値が 'cleanup_delay' より大きい場合、rejectは
	#  リクエストが内部キャッシュから削除される 'cleanup_delay' 時間後に送信されます。
	#
	#  小数も指定可能です（例: 3.4）。
	#
	#  推奨範囲: 1～5
	#
	reject_delay = 1

	#
	#  status_server: サーバーが Status-Server リクエストに応答するかどうか。
	#
	#  Status-Server メッセージを受信すると、サーバーは
	#  Access-Accept または Accounting-Response パケットで応答します。
	#
	#  これは、テストユーザーを追加したり偽のアカウンティングパケットを
	#  作成したりせずに、管理者がサーバーを「ping」したい場合に便利です。
	#
	#  また、NASがRADIUSサーバーを「dead」とマークした場合にも有用です。
	#  NASは定期的に Status-Server パケットでサーバーを「ping」できます。
	#  サーバーが応答すれば生きていることになり、NASは本番リクエストに
	#  使い始めることができます。
	#
	#  raddb/sites-available/status も参照してください。
	#
	status_server = yes

	#
	#  Message-Authenticator をすべての Access-* パケット（UDP/TCP）で
	#  必須とするグローバル設定。このフラグはTLSでは無視されます。
	#
	#  BlastRADIUS攻撃から自分を守る最善の方法は、すべてのRADIUSサーバーを
	#  アップデートし、このフラグを "yes" に設定することです。
	#  すべてのRADIUSサーバーがアップデートされ、すべてのクライアントに
	#  このフラグが "yes" で設定されていれば、ネットワークは安全です。
	#  その後、クライアントのアップグレードは急がずに行えます。
	#
	#  このフラグはすべてのクライアントとホームサーバーのグローバルデフォルトを
	#  設定します。個別のクライアントやホームサーバー定義で同じフラグを
	#  追加することで上書きできます。
	#
	#  すべてのアップグレードされたRADIUS実装は、すべての Access-Request、Access-Accept、
	#  Access-Reject、および Access-Challenge パケットに Message-Authenticator を送信する必要があります。
	#  すべてのシステムがアップグレードされたら、このフラグを "yes" に設定することが
	#  攻撃からの最良の保護となります。
	#
	#  許可値と "require_message_authenticator" の意味は次のとおりです。
	#
	#  * "no" - Message-Authenticator を含まない Access-* パケットを許可する
	#
	#    クライアントの場合、このフラグが "no" に設定されていると、
	#    下記の "limit_proxy_state" フラグもチェックされます。
	#
	#    ホームサーバーの場合、このフラグが "no" に設定されていると、
	#    Access-Accept、Access-Reject、および Access-Challenge パケットは
	#    Message-Authenticator を含む必要がありません。
	#
	#    このフラグを "no" に設定する唯一の理由は、RADIUS クライアントまたは
	#    ホームサーバーがアップデートされていない場合です。常にこのフラグを
	#    個別のクライアントまたは home_server 定義で "no" に設定する方が安全です。
	#    グローバルフラグは依然として安全な値 "yes" に設定されているべきです。
	#
	#    警告: このフラグと "limit_proxy_state" フラグの両方を "no" に設定すると、
	#    MITM 攻撃者が偽の Access-Accept パケットを NAS に作成することを許可します！
	#    システムに攻撃に対する保護を持たせるためには、これらのうち少なくとも
	#    1 つは "yes" に設定する必要があります。
	#
	#  * "yes" - すべての Access-* パケット（クライアントとホームサーバー）が
	#    Message-Authenticator を含むことを要求します。パケットに Message-Authenticator
	#    が含まれていない場合、そのパケットは破棄されます。
	#
	#  * "auto" - フラグの値を自動的に決定します。
	#    クライアントまたはホームサーバーから受信した最初のパケットに基づいています。
	#
	#    パケットに Message-Authenticator が含まれていない場合、フラグの値は
	#    自動的に "no" に切り替わります。
	#
	#    パケットに Message-Authenticator が含まれているが EAP-Message が含まれていない場合、
	#    フラグの値は自動的に "yes" に切り替わります。以前の RFC では、パケットが
	#    EAP-Message を含む場合、Message-Authenticator も含まれることが要求されていました。
	#    そのため、これらのパケットに Message-Authenticator が含まれていることは、
	#    クライアントまたはホームサーバーがアップグレードされているかどうかを判断する
	#    には不十分です。
	#
	#    パケットに Message-Authenticator と EAP-Message の両方が含まれている場合、
	#    フラグは "auto" の値のままにされます。
	#
	#    警告: この切り替えは、そのクライアントまたはホームサーバーから受信した最初の
	#    パケットに対して行われます。変更はサーバーの再起動を超えて持続しません。
	#    永続的に設定を変更するには、手動で "yes" に変更する必要があります。
	#
	#    警告: 同じソース IP とクライアント定義を持つ複数の NAS があり、
	#    しかし NAS ごとに動作が異なる場合、このフラグはネットワークを壊す可能性があります。
	#
	#    つまり、1 つの NAT された IP アドレスの背後に複数の異なる RADIUS クライアントが
	#    存在する場合、これらのセキュリティ設定は、最も安全でないパケットを処理できるように
	#    設定する必要があります。これはひどいアイデアであり、ネットワークを攻撃に対して脆弱にします。
	#    すべてのクライアントを直ちにアップグレードしてください。
	#
	require_message_authenticator = auto

	#
	#  Proxy-State と Message-Authenticator の組み合わせを制限する
	#  グローバル設定。このフラグはクライアントから送信される
	#  Access-Request パケット（UDP/TCP）にのみ適用されます。
	#  TLS では無視されます。
	#
	#  このフラグはすべてのクライアントのグローバルデフォルトを設定します。
	#  個別のクライアント定義で同じフラグを追加することで上書きできます。
	#
	#  "require_message_authenticator" が "yes" の場合、この設定は無視されます。
	#
	#  "require_message_authenticator" が "no" の場合、この設定がチェックされます。
	#
	#  "limit_proxy_state" の値と意味は次のとおりです。
	#
	#  * "no" - クライアントからのすべての Access-Request パケットを許可します。
	#    BlastRADIUS攻撃を含むパケットも許可されます。
	#    この設定ではサーバーが受信するすべてのパケットについて警告します。
	#
	#    このフラグを "no" に設定する唯一の理由は、クライアントがプロキシであり、
	#    かつ Access-Request パケットに Message-Authenticator を送信しない場合です。
	#    それでも、最善の方法は (1) プロキシをアップデートして
	#    Message-Authenticator を送信させること、もしできない場合は
	#    (2) このフラグを "no" に設定しますが、そのクライアントだけに限定してください。
	#    グローバルフラグは依然として安全な値 "yes" に設定されているべきです。
	#
	#    警告: このフラグと "require_message_authenticator" フラグの両方を "no" に設定すると、
	#    MITM攻撃者が Access-Request パケットを偽装し、NASに偽の Access-Accept パケットを
	#    作成できるようになります！システムに攻撃に対する保護を持たせるためには、
	#    これらのうち少なくとも1つは "yes" に設定する必要があります。
	#
	#  * "yes" - Message-Authenticator を含まない Access-Request パケットも許可しますが、
	#    Proxy-State を含まない場合のみです。Proxy-State を含むパケットは
	#    Message-Authenticator も含まれていなければ破棄されます。
	#
	#    この設定はほとんどのNAS、GGSN、BRAS等で安全です。
	#    通常のRADIUSクライアントは、自分で生成したAccess-Requestパケットに
	#    Proxy-State属性を付与しません。ただし、一部のアグリゲータ
	#    （例: 無線LANコントローラ）は、管理下のデバイスからのリクエストを
	#    RADIUSプロキシとして転送する際に Proxy-State 属性を付与する場合があります。
	#    その場合は実際のパケットを確認し、必要に応じてWLCをアップグレードし
	#    "require_message_authenticator" を "yes" に設定してください。
	#
	#  * "auto" - クライアントから受信した最初の Access-Request パケットに基づき
	#    フラグの値を自動的に決定します。
	#
	#    パケットに Proxy-State が含まれていて Message-Authenticator が含まれていない場合、
	#    フラグの値は自動的に "no" に切り替わります。
	#
	#    それ以外の場合は自動的に "yes" に切り替わります。
	#
	#    警告: この切り替えは、そのクライアントから受信した最初のパケットに対して行われます。
	#    変更はサーバーの再起動を超えて持続しません。永続的に設定を変更するには
	#    手動で "yes" に変更する必要があります。
	#
	#    警告: 同じソース IP とクライアント定義を持つ複数の NAS があり、
	#    しかし NAS ごとに動作が異なる場合、このフラグはネットワークを壊す可能性があります。
	#
	#    つまり、1 つの NAT された IP アドレスの背後に複数の異なる RADIUS クライアントが
	#    存在する場合、これらのセキュリティ設定は、最も安全でないパケットを処理できるように
	#    設定する必要があります。これはひどいアイデアであり、ネットワークを攻撃に対して脆弱にします。
	#    すべてのクライアントを直ちにアップグレードしてください。
	#
	#    このような稀な構成の場合の唯一の解決策は、このフラグを "no" に設定することです。
	#    その場合ネットワークは動作しますが、攻撃に対して脆弱になります。
	#
	limit_proxy_state = auto


}

# PROXY CONFIGURATION
#
#  proxy_requests: RADIUSリクエストのプロキシ機能を有効/無効にします。
#
#  サーバーはデフォルトでプロキシ機能が有効です。システムが他のサーバーへ
#  リクエストをプロキシする設定でない場合は、ここでプロキシ機能を
#  無効にできます。これによりサーバーのリソースを少し節約できます。
#
#  プロキシ機能を無効にしている場合、設定ファイルでプロキシを
#  指定しているとエラーメッセージが記録されます。
#
#  プロキシを無効にするには "yes" を "no" に変更し、
#  $INCLUDE 行をコメントアウトしてください。
#
#  許可値: {no, yes}
#
proxy_requests  = yes
$INCLUDE proxy.conf


# CLIENTS CONFIGURATION
#
#  クライアントの設定は "clients.conf" で定義されています。
#

#  'clients.conf' ファイルには、旧 'clients' および 'naslist'
#  設定ファイルのすべての情報が含まれています。
#  できるだけ 'clients' や 'naslist' は使わず、'clients.conf' を
#  利用することを推奨します（旧ファイルもサポートはされています）。
#
#  'clients.conf' に記載された内容は、旧形式の設定ファイルよりも
#  優先されます。
#
$INCLUDE clients.conf


# THREAD POOL CONFIGURATION
#
#  スレッドプールは、着信リクエストをラウンドロビンで処理する
#  長寿命のスレッド群です。
#
#  高負荷時に即座に対応できるよう、予備スレッドをいくつか
#  用意しておくとよいでしょう。予備スレッドがない場合、
#  新しいスレッドが作成されプールに追加されるまで
#  リクエスト処理が遅延します。
#
#  逆に予備スレッドが多すぎると、リソースを無駄に消費します。
#
#  下記の数値はほとんどのケースで十分です。
#
thread pool {
	#  サーバー起動時に開始するスレッド数（目安）。
	start_servers = 5

	#  実行中のサーバー（スレッド）の最大数。
	#
	#  この上限に達するとクライアントはロックアウトされるため、
	#  値を低くしすぎないでください。暴走サーバーが
	#  システム全体を巻き込むのを防ぐためのブレーキです。
	#
	#  サーバーが頻繁に 'max_servers' に達し、値を増やしても
	#  効果がない場合、バックエンドDBの応答が遅いことが
	#  主な原因です。'max_servers' を増やすのではなく、
	#  根本原因（遅いDBや 'hostname_lookups=yes'）を
	#  解決してください。
	#
	#  詳細は上記 'max_request_time' を参照してください。
	#
	max_servers = 32

	#  サーバープールのサイズ調整。
	#  必要なサーバー数を推測する代わりに、FreeRADIUSは
	#  現在の負荷に応じて動的にサーバー数を調整します。
	#  現在の負荷＋一時的なスパイクに対応できるだけの
	#  サーバーを維持しようとします。
	#
	#  定期的に待機中のサーバー数をチェックし、
	#  min_spare_servers 未満なら新たな予備を作成、
	#  max_spare_servers を超えていれば予備を減らします。
	#  デフォルト値でほとんどのサイトは十分です。
	#
	min_spare_servers = 3
	max_spare_servers = 10

	#  サーバーがパケットを受信すると、内部キューに格納され、
	#  上記で設定したワーカースレッドが処理します。
	#  このキューの最大サイズをここで指定します。
	#
	#  キューが満杯になると、新しいパケットは黙って破棄されます。
	#
	#  キューが満杯になる主な原因は、サーバーが遅いDBに依存していて
	#  大量のトラフィックが一時的に発生した場合です。
	#  この場合、サーバーへのトラフィックを減らすか、
	#  DBの処理能力を上げるかしかありません。
	#
#	max_queue_size = 65536

	#  古いスレッドを定期的にクリーンアップします。
	#  特に理由はありませんが、役立つ場合があります。
	#
	#  '0' は特別な値で「無限」または「サーバーは終了しない」ことを意味します。
	max_requests_per_server = 0

	#  アカウンティングリクエスト数を自動的に制限します。
	#  この設定項目は、サーバーが1秒あたりに処理できるリクエスト数を
	#  追跡します。受信パケット/秒と子スレッドで処理された
	#  パケット/秒を比較します。
	#

	#  受信PPSが処理PPSより大きく、かつキューが半分以上埋まっている場合、
	#  新しいアカウンティングリクエストは確率的に破棄されます。
	#  これによりサーバーが処理すべきパケット数が減ります。
	#  時間が経てばサーバーはトラフィックに「追いつき」ます。
	#
	#  アカウンティングパケットを破棄しても通常は安全で影響は小さいです。
	#  NASは数秒～数分後に再送します。ベンダーはRFC 5080 2.2.1節を
	#  参照してください。これ以外の方法はネットワーク障害の原因になります。
	#
	auto_limit_acct = no
}

######################################################################
#
#  SNMP通知。snmptrapsを有効にするには、次の行のコメントを外してください。
#  なお "trigger.conf" ファイルで "snmptrap" コマンドのフルパスも
#  設定する必要があります。
#
#$INCLUDE trigger.conf

# モジュール設定
#
#  各モジュールの名前と設定はこのセクションで定義します。
#
#  ここで定義したモジュールは、この設定ファイルの他のセクションで
#  名前で参照できます。
#
modules {
	#
	#  各モジュールの設定例:
	#
	#	name [ instance ] {
	#		config_item = value
	#		...
	#	}
	#
	#  'name' は rlm_name ライブラリをロードするために使われます。
	#  これがモジュールの機能を実装します。
	#
	#  'instance' は省略可能です。モジュールを2つのインスタンスで
	#  使いたい場合、まず 'name' で参照し、異なる 'instance' 名
	#  （例: instance1, instance2）を作成します。
	#
	#  instance名は以降の設定で元のnameの代わりに使えます。
	#  'radutmp' 設定例を参照してください。
	#

	#
	#  一部のモジュールには読み込み順序の問題があります。
	#  例: "sqlippool" は "sql" の設定を利用します。
	#  この場合、"sql" モジュールを "sqlippool" より先に
	#  ディスクから読み込む必要があります。
	#  ただし、下記のディレクトリインクルードは
	#  ディレクトリを最初から最後まで順に読み込むだけなので、
	#  モジュールの読み込み順はランダムになります。
	#
	#  個別のモジュールをディレクトリインクルードより前に
	#  リストすることができます。そうすると、それらのモジュールが
	#  先にロードされ、ディレクトリを読む際には
	#  2重に読み込まれません。
	#
#	$INCLUDE mods-enabled/sql

	#
	#  すべてのモジュールは mods-enabled/ ディレクトリにあります。
	#  正規表現 /[a-zA-Z0-9_.]+/ にマッチするファイルが読み込まれます。
	#  モジュールは、authorize, authenticate, accounting, pre/post-proxy
	#  などの処理セクションで参照された場合のみ初期化されます。
	#
	$INCLUDE mods-enabled/
}

# Instantiation
#
#  このセクションでは、モジュールのインスタンス化順序を設定します。
#  ここでリストされたモジュールは、authorize や authenticate などの
#  セクションが処理される前に起動されます。
#
#  このセクションは必須ではありません。authorize などのセクションで
#  モジュールが参照されると、自動的にロード・初期化されます。
#  ただし、どの処理セクションにもリストされていないモジュールが
#  ある場合は、ここでリストしておく必要があります。
#
#  また、ここでモジュールをリストすることで、初期化順序を
#  コントロールできます。あるモジュールが他のモジュールで
#  定義されたものを必要とする場合、ここで順序を指定できます。
#
#  ここでリストされたモジュールがロードされた後、
#  "mods-enabled" ディレクトリ内のすべてのモジュールがロードされます。
#  "mods-enabled" ディレクトリのロードにより、バージョン2とは異なり
#  通常ここにモジュールをリストする必要はありません。
#
instantiate {
	#
	#  ここでcounterモジュールをリストすることで、
	#  他のモジュールがcheck_name属性を設定する前に
	#  それを登録できます
#	daily

	#  ここでのサブセクションは「仮想」モジュールと考えられます。
	#
	#  例: 冗長なSQLサーバーが2台あり、authorizeやaccountingセクションで
	#  それらを使いたい場合、各セクションに同じ内容の"redundant"ブロックを
	#  記述する代わりに、以下の行をアンコメントして
	#  authorizeやaccountingセクションで"redundant_sql"をリストできます。
	#
	#  ここで定義された「仮想」モジュールは、いくつかの条件下で
	#  動的展開にも使えます:
	#
	#  * セクションが "redundant"、"load-balance"、"redundant-load-balance" のいずれか
	#  * セクション内がモジュールのみでサブセクションがない
	#  * すべてのモジュールが同じrlm_ドライバ（例: すべてsql、すべてldap等）を使っている
	#
	#  これらの条件を満たすと、サーバーは「仮想」モジュール名で
	#  動的展開を自動登録します。下記例では "redundant_sql" です。
	#  これを他のモジュールと同様に使えます:
	#
	#	update reply {
	#		Filter-Id := "%{redundant_sql: ... }"
	#	}
	#
	#  この例では、展開は"sql1"モジュールで行われ、
	#  失敗した場合は"sql2"モジュールが使われます。
	#
	#  最良の結果を得るには、モジュールの"pool"サブセクションで
	#  "retry_delay"を0以外に設定してください。これにより
	#  冗長ブロックがダウンしたSQLデータベースを素早く無視できます。
	#  "retry_delay = 0"の場合、冗長ブロックが使われるたびに
	#  すべてのダウンしたデータベースに接続しようとするため
	#  問題が発生します。
	#
	#redundant redundant_sql {
	#	sql1
	#	sql2
	#}
}

######################################################################
#
#  ポリシーは、上記の "instantiate" セクションで定義されたものと
#  似た仮想モジュールです。
#
#  policy.d ファイルのいずれかでポリシーを定義すると、
#  一連の条件やアクションとしてではなく「名前」として
#  複数箇所で参照できます。
#
#  ポリシーは通常の言語のサブルーチンのようなものですが、
#  再帰呼び出しはできません。必ず順番に定義する必要があります。
#  ポリシーAがポリシーBを呼ぶ場合、BはAより前に定義されていなければなりません。
#
######################################################################
policy {
	$INCLUDE policy.d/
}

######################################################################
#
#	仮想サーバーのロード
#
#	次の $INCLUDE 行は、ディレクトリ内の
#	正規表現 /[a-zA-Z0-9_.]+/ にマッチするファイルをロードします。
#
#	これにより、raddb/sites-enabled/ ディレクトリに
#	ファイルを置くだけで新しい仮想サーバーを定義できます。
#
$INCLUDE sites-enabled/

######################################################################
#
#	"authorize {}"、"authenticate {}"、"accounting {}" などの
#	他のすべての設定セクションは、次のファイルに移動されました:
#
#		raddb/sites-available/default
#
#	これはバージョン1.0.xおよび1.1.xと同じ設定を持つ
#	「default」仮想サーバーです。デフォルトインストールでは
#	この仮想サーバーが有効になっています。ローカルサイト用の
#	ポリシーを作成するにはこれを編集してください。
#
#	仮想サーバーの詳細なドキュメントは以下を参照してください:
#
#		raddb/sites-available/README
#
######################################################################
